import logging
from datetime import date
import random
from tablib import Dataset
import csv
from datetime import datetime
import pandas as pd

from django.db.models import Q
from decimal import Decimal
from django.utils import timezone


from whatsapp.tasks import (
    send_driver_assignment_to_driver_or_taseron, 
    send_driver_removal_to_driver_or_taseron, 
) 
from common.models import Rate
from common.tasks import refresh_currency_rate


logger = logging.getLogger('transfertakip')

def calculate_zero_tl_expense_amount_field(expenses=None):
    if expenses is None:
        return 
    amount_tl_zeros = expenses.filter(
        amount_tl__lt=Decimal('0.05'), 
        currency__isnull=False)

    # amount_tl is zero
    for expense in amount_tl_zeros:
        todays_rate = Rate.objects.filter(
            currency=expense.currency, 
            rate_date=expense.date).first()
        if todays_rate:
            expense.amount_tl = expense.amount * todays_rate.buying_rate
        else:
            if expense.currency:
                refresh_currency_rate.delay(currency_id=expense.currency.id, rate_date=expense.transfer_date)
            expense.amount_tl = 0.00
        expense.save()

def is_unique_reservation_number(reservation_number=None):
    from company.models import Reservation
    return not Reservation.objects.filter(number=reservation_number).exists()

def get_autogenerated_reservation_number(company_code=None):
    logger.debug(f"inside generate_reservation_number, company_code: {company_code}")
    reservation_number = None
    # Remove the first 2 digit from the timestamp to make it short
    unix_timestamp = str(int(timezone.localtime(timezone.now()).timestamp()))[2:]
    random_number = '00'
    # logger.debug(f"random_number: {random_number}")
    # logger.debug(f"unix_timestamp: {unix_timestamp}")
    while True:
        # Remove the first 2 digit from the timestamp to make it short
        unix_timestamp = str(int(timezone.localtime(timezone.now()).timestamp()))[2:]
        
        # Create the reservation number
        reservation_number = f"TT{random_number}-{unix_timestamp}-{company_code.upper()}"
        # logger.debug(f"reservation_number: {reservation_number}")
        # Check if the reservation number is unique
        if is_unique_reservation_number(reservation_number):
            break

        # Remove the first 2 digit from the timestamp to make it short
        unix_timestamp = str(int(timezone.localtime(timezone.now()).timestamp()))[2:]
        # Generate a random 2-digit number between 10 and 99
        random_number = random.randint(10, 99)
    # logger.debug(f"return reservation_number: {reservation_number}")
    return reservation_number
    
def remove_empty_rows(dataset):
    """
    Remove completely empty rows from the dataset.
    """
    cleaned_data = Dataset(headers=dataset.headers)
    for row in dataset.dict:
        # Check if all values in the row are empty
        if any(row.values()):  # If there's at least one non-empty value
            cleaned_data.append(row.values())
        logger.debug(f"cleaned_data: {cleaned_data}")
    return cleaned_data


def clean_excel_file(file):
    # df = pd.read_excel(file).dropna(how='all')  # Drop rows where all values are NaN
    df = pd.read_excel(file, dtype=str).fillna('').dropna(how='all')
    df = df.applymap(str.strip)  # Remove whitespace

    df['Transfer Tarihi'] = pd.to_datetime(
        df['Transfer Tarihi'], errors='coerce').dt.date
    df['Transfer Saati'] = pd.to_datetime(
        df['Transfer Saati'], errors='coerce').dt.time
    df['Uçuş Tarihi'] = pd.to_datetime(
        df['Uçuş Tarihi'], errors='coerce').dt.date
    df['Uçuş Saati'] = pd.to_datetime(
        df['Uçuş Saati'], errors='coerce').dt.time
    df['Rezervasyon Tarihi'] = pd.to_datetime(
        df['Rezervasyon Tarihi'], errors='coerce').dt.date
    
    dataset = Dataset()
    dataset.headers = df.columns.tolist()

    for row in df.itertuples(index=False, name=None):
        dataset.append(row)
    return dataset

def clean_csv_file_with_pandas(file):
    try:
        df = pd.read_csv(file, dtype=str).fillna('').dropna(how='all')
    except pd.errors.ParserError as e:
        raise ValueError(f"Error parsing CSV file: {e}")
    df = df.applymap(str.strip)  # Remove whitespace

    df['Transfer Tarihi'] = df['Transfer Tarihi'].fillna(None)
    df['Transfer Saati'] = df['Transfer Saati'].fillna(None)
    df['Uçuş Tarihi'] = df['Uçuş Tarihi'].fillna(None)
    df['Uçuş Saati'] = df['Uçuş Saati'].fillna(None)
    df['Rezervasyon Tarihi'] = df['Rezervasyon Tarihi'].fillna(None)


    df['Transfer Tarihi'] = pd.to_datetime(
        df['Transfer Tarihi'], errors='coerce').dt.date
    df['Transfer Saati'] = pd.to_datetime(
        df['Transfer Saati'], errors='coerce').dt.time
    df['Uçuş Tarihi'] = pd.to_datetime(
        df['Uçuş Tarihi'], errors='coerce').dt.date
    df['Uçuş Saati'] = pd.to_datetime(
        df['Uçuş Saati'], errors='coerce').dt.time
    df['Rezervasyon Tarihi'] = pd.to_datetime(
        df['Rezervasyon Tarihi'], errors='coerce').dt.date
    
    dataset = Dataset()
    dataset.headers = df.columns.tolist()

    for row in df.itertuples(index=False, name=None):
        dataset.append(row)
    return dataset


def clean_csv_file(file):
    dataset = Dataset()

    try:
        # Open the uploaded CSV file
        csv_file = csv.reader(file.read().decode("utf-8").splitlines())
        
        # Get the header row
        headers = next(csv_file)
        dataset.headers = [header.strip() for header in headers]

        # Process rows
        for row in csv_file:
            cleaned_row = [field.strip() for field in row]  # Strip whitespace
            dataset.append(cleaned_row)

        # Log total rows processed
        logger.debug(f"Total rows processed: {len(dataset)}")

    except Exception as e:
        logger.error(f"Error processing CSV file: {e}")
        raise ValueError("Failed to parse CSV file. Ensure the format is correct.")

    return dataset

def get_status_update(initial_reservation=None, new_reservation=None):
    # if previous status is confirmed, and if reservation has driver or taseron
    # then status is 'inoperation'
    # else status is 'confirmed'
    status = new_reservation.status
    if not initial_reservation:
        return status
    if initial_reservation.status in ['confirmed', 'inoperation'] \
        and new_reservation.status in ['confirmed', 'inoperation']:
        if new_reservation.my_driver or new_reservation.taseron:
            return 'inoperation'
        else:
            return 'confirmed'
    return status